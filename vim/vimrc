execute pathogen#infect()
" automatically generate helptags for all plugins
execute pathogen#helptags()  

filetype on
syntax on
filetype plugin indent on

" there are many known security issues involving modelines, best to disable them
set modelines=0

set encoding=utf-8

" solarized setup
set background=dark
colorscheme solarized

" turn on relative line numbers
" but show the absolute line number for the line the cursor is on
set relativenumber
set number

" display a line at 80 characters
set colorcolumn=80

" highlight the line the cursor is on (can be toggled with unimpaired)
set cursorline

" text wrap settings
"set textwidth=79 " automatically break lines after this many chars
"set formatoptions=??

" search options 
set hlsearch      " highlight the search term
set incsearch     " show results incrementally as you type (like google instant search)
set ignorecase    
set smartcase     " overrides ignorecase if there are capital letters in the search string
set gdefault      " apply substitutions globally on lines by default

" get rid of the annoying popping sound on errors
set noerrorbells
set visualbell

" make backspace behave like it is supposed to
set backspace=eol,start,indent

" keep 10 lines of context when moving vertically
set so=10

" make sure tab width is 4 when displaying, editing, and indenting text
" but keep actual tab width at default (8) to preserve formatting in 
" other text editors 
set softtabstop=4 shiftwidth=4 noexpandtab autoindent shiftround smarttab

" Use the same symbols as TextMate for tabstops and EOLs
set listchars=tab:▸\ ,eol:¬

" preserve code folds between sessions
autocmd BufWinLeave * if expand("%") != "" | mkview | endif
autocmd BufWinEnter * if expand("%") != "" | loadview | endif
" but don't preserve the current .vimrc settings
set viewoptions-=options

" autosave
au FocusLost * nested silent! wa

" always show the statusline
set laststatus=2
set showtabline=2
set noshowmode
" show partial commands (in visual mode, shows size of selected area)
set showcmd

" enable wildmenu for advanced tab completion in command mode
set wildmenu
set wildmode=list:longest

set ttyfast

" make vim create "undo files" whenever we edit a file
" these allow us to undo changes, even after closing and reopening a file
set undofile

" the sweet spot for timeoutlen
" low enough that the transition from insert mode to normal mode feels
" seamless, high enough that key combos can be executed at a reasonable
" speed without timing out
set timeoutlen=150

" options for syntax/python.vim
let python_version_2=1
let python_highlight_builtins=1
let python_highlight_exceptions=1
let python_highlight_string_formatting=1
let python_print_as_function=1

" options for simpylfold
autocmd BufWinEnter *.py setlocal foldexpr=SimpylFold(v:lnum) foldmethod=expr
autocmd BufWinLeave *.py setlocal foldexpr< foldmethod<
" xml linter
au FileType xml exe ":silent %!xmllint --format --recover - 2>/dev/null"

" syntastic settings
" these three were not playing well with airline, see :h airline-syntastic
"set statusline+=%#warningmsg#
"set statusline+=%{SyntasticStatuslineFlag()}
"set statusline+=%*

"let g:syntastic_error_symbol = '✗'
"let g:syntastic_warning_symbol = '!'
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

let g:syntastic_cpp_compiler_options = "-std=c++11 -fsyntax-only"

" airline settings
let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#whitespace#enabled = 0
let g:airline#extensions#syntastic#enabled = 1
" disable powerline.vim (because I'm using airline instead)
let g:powerline_loaded = 1

" vimtex settings
let g:tex_flavor = "latex"
let g:vimtex_latexmk_options = "-pdf -dvi-"
let g:vimtex_view_method = "mupdf"
augroup vimtex_config
    au!
    au User VimtexEventQuit      VimtexClean
    au User VimtexEventInitPost  VimtexCompile
augroup END

" unite.vim settings
function! s:unite_settings()
    imap <buffer> <C-[> <plug>(unite_exit)
    imap <buffer> <C-j> <plug>(unite_select_next_line)
    imap <buffer> <C-k> <plug>(unite_select_previous_line)
endfunction
autocmd FileType unite call s:unite_settings()

let g:unite_prompt = '»'
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])
"let g:unite_source_history_yank_enable=1
"let g:unite_source_rec_max_cache_files=5000
let g:unite_source_grep_command = 'ack'
let g:unite_source_grep_default_opts = '-i --no-heading --no-color -k -H' 
let g:unite_source_grep_recursive_opt = ''
" note: both ctrl-l and ctrl-g (g for grep) overwrite builtin vim commands
nnoremap <C-l> :Unite -buffer-name=mixed -start-insert -auto-resize buffer file_mru file_rec/async:!<CR> 
nnoremap <C-g> :Unite -buffer-name=search -no-empty -no-quit -auto-resize grep:.<CR>
" use line source ??

" rainbow parentheses settings
let g:rainbow_active = 0 " only active when explicitly activated via :RainbowToggle
let g:rainbow_conf = {
    \   'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick'],
    \   'ctermfgs': ['lightblue', 'NavyBlue', 'lightgreen', 'darkmagenta'],
    \   'operators': '_,_',
    \   'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold',
    \                   'start=/{/ end=/}/ fold'],
    \   'separately': {
    \       '*': {},
    \       'tex': {
    \           'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/'],
    \       },
    \       'lisp': {
    \           'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick',
    \                      'darkorchid3'],
    \       },
    \       'vim': {
    \           'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/',
    \                           'start=/{/ end=/}/ fold', 'start=/(/ end=/)/ containedin=vimFuncBody',
    \                           'start=/\[/ end=/\]/ containedin=vimFuncBody',
    \                           'start=/{/ end=/}/ fold containedin=vimFuncBody'],
    \       },
    \       'html': {
    \           'parentheses': ['start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold'],
    \       },
    \       'css': 0,
    \   }
    \}
" toggle rainbow parens
nnoremap cop :RainbowToggle<CR>

" ultisnips settings
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<c-j>"
let g:UltiSnipsJumpBackwardTrigger="<c-k>"
let g:UltiSnipsEditSplit="vertical"

"""""""""""""""""""
"" Abbreviations ""
"""""""""""""""""""
abbr Flase False

"""""""""""""""""""""
"" Custom Fuctions ""
"""""""""""""""""""""

" Implements the window movement keybindings
function! WinMove(key) 
  let t:curwin = winnr()
  exec "wincmd ".a:key
  if (t:curwin == winnr()) "we havent moved
    if (match(a:key,'[jk]')) "were we going up/down
      wincmd v
    else 
      wincmd s
    endif
    exec "wincmd ".a:key
  endif
endfunction

""""""""""""""""""
"" Key Bindings ""
""""""""""""""""""

" set a mapleader that doesn't suck :3
let mapleader = "\<Space>"
let g:mapleader = "\<Space>"

let maplocalleader = "`"
let g:maplocalleader = "`"

" Escape to return to normal mode is probably the command issued the most,
" so why move your hands from the home row to do it?
inoremap jk <ESC>
inoremap kj <ESC>
vnoremap jk <ESC>
vnoremap kj <ESC>
" Also ween myself off of the old way of escaping
inoremap <c-[> <NOP>
vnoremap <c-[> <NOP>
" Fast save
nmap <leader>w :w!<CR>
" Quick quit w/o saving
nnoremap ZX ZQ
nnoremap XZ ZQ
" Quick close all buffers
nnoremap <leader>z :qa<CR>
" Quick close all buffers w/o saving
nnoremap <leader>Z :qa!<CR>
" Quick shell cmd execution
nnoremap :: :!
" Clear highlighting from last search
nnoremap <F3> :let @/ = ""<CR>

" Easy window movement, opening, closing, and swapping
" lowercase asdf to move to a window in that direction
" if there is no window in that direction, create one
map <leader>a        :call WinMove('h')<cr>
map <leader>s        :call WinMove('j')<cr>
map <leader>d        :call WinMove('k')<cr>
map <leader>f        :call WinMove('l')<cr>
" uppercase ASDF to swap windows
map <leader>A        :wincmd H<cr>
map <leader>S        :wincmd J<cr>
map <leader>D        :wincmd K<cr>
map <leader>F        :wincmd L<cr>
" close a window
map <leader>c        :wincmd q<cr>
" rotate windows
map <leader>r        <C-W>r

" Close buffer (depends on bbye plugin)
nmap <leader>q :Bdelete<cr>
" Use [b and ]b to switch between buffers within a window
" See `:help unimpaired-next`

" Intuitive movement, even with wrapped lines
noremap <buffer> <silent> k gk
noremap <buffer> <silent> j gj
"noremap <buffer> <silent> 0 g0
"noremap <buffer> <silent> $ g$
" Yank to system clipboard. Text to be yanked should be selected with visual
" mode
vnoremap gy "+y
" Paste from system clipboard. This overwrites a builtin vim movement!
nnoremap gp "+p 
nnoremap gP "+P
" Easy paste that is never overridden by delete
nnoremap <leader>p "0p
nnoremap <leader>P "0P
" repeat the last normal mode command in visual mode
vnoremap . :norm.<CR>
