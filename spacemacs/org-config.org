#+PROPERTY: header-args :tangle yes
* general settings
These are probably the most well-known org-mode settings. I keep my org files in
~$HOME/s/doc/org~. I like my org files to be completely folded when I open them.
I also have to turn on org-indent-mode because it [[https://github.com/syl20bnr/spacemacs/issues/2732][isn't a spacemacs default]]
right now and it makes me sad :'(.
#+BEGIN_SRC emacs-lisp
  (setq-default
   ;; default place to look for org files
   org-directory "~/s/doc/org"
   ;; prevent org files from opening to random sections when I open them
   org-startup-folded t
   ;; move tags over to the right
   org-tags-column -100
   ;; make subheadings indented by 4 spaces
   org-indent-indentation-per-level 2
   ;; also make plain sublists indented by 4 spaces
   org-list-indent-offset 2
   ;; enable org-indent-mode globally
   org-startup-indented t
   org-log-done nil ;; don't insert a CLOSED timestamp when I complete a task
   org-lowest-priority 69 ;; Priorities are in the range "A" to "E"
   org-default-priority 68 ;; Default priority is "D"
   ;; change the attachment directory name from "data" to "media"
   org-attach-directory "media/"
   ;; set org-download to use org-attach
   org-download-method 'attach
   )
#+END_SRC

I like to link between org files using the "id" property. The list of ids and
their locations is kept in ~org-id-locations-file~. I've moved this file from
its default location in ~$HOME/.emacs.d~ to my ~org-directory~, which is synced
between my devices. This way the links work on every device.
#+BEGIN_SRC emacs-lisp
  (setq-default org-id-locations-file (concat org-directory "/.org-id-locations"))
#+END_SRC

This setting allows me to navigate org-files a little bit more easily by
changing the behavior of ~C-a~ and ~C-e~ in org-mode. At least that's what it's
supposed to do, but because of spacemacs customizations to org-mode, this
setting actually affects the evil-org keybindings ~^~ and ~$~. See the spacemacs
org layer docs and [[https://emacs.stackexchange.com/questions/17502/how-to-navigate-most-efficiently-to-the-start-or-end-of-the-main-text-of-an-org][this stack overflow post]] for more.
#+BEGIN_SRC emacs-lisp
  (setq-default org-special-ctrl-a/e t)
#+END_SRC
* todo keywords
I have two todo cycles. The first one is for tasks and projects, and the second
is exclusively for habits. TODO items are those that I plan to start in the near
future, WAITING means I started the task but am waiting for some external event
to happen before I can complete it, HOLD means the task is on hold for now (I
make sure to log the reason why), and DONE means done.
#+BEGIN_SRC emacs-lisp
  (setq-default
    org-todo-keywords '((sequence "TODO(t!)" "NEXT(n!)" "|" "WAITING(w@)" "HOLD(h@)" "STUCK(s@)" "CANCELLED(x@)" "DONE(d!)")
                        (sequence "HABIT" "|" "COMPLETE(c!)"))
    org-todo-keyword-faces
    '(("WAITING" . (:foreground "#b58900" :weight bold))
      ("HOLD" . (:foreground "#dc322f" :weight bold))
      ("HABIT" . (:foreground "#6c71c4" :weight bold))
      ("NEXT" . (:foreground "#cb4b16" :weight bold))
      ("CANCELLED" . (:foreground "#dc322f" :weight bold))
      ("STUCK" . (:foreground "#6c71c4" :weight bold))))
#+END_SRC
* agenda
The function ~sa-find-file-recursively~ was taken from [[ https://stackoverflow.com/questions/11384516/how-to-make-all-org-files-under-a-folder-added-in-agenda-list-automatically#11384907][this stack overflow post]].
#+BEGIN_SRC emacs-lisp
  (defun sa-find-org-file-recursively (&optional directory filext)
    "Return .org and .org_archive files recursively from DIRECTORY.
      If FILEXT is provided, return files with extension FILEXT instead."
    (interactive "DDirectory: ")
    (let* (org-file-list (case-fold-search t) ; filesystems are case sensitive
                         (file-name-regex "^[^.#].*") ; exclude dot, autosave, and backup files

                         (filext (or filext "org$\\\|org_archive"))
                         (fileregex (format "%s\\.\\(%s$\\)" file-name-regex filext))
                         (cur-dir-list (directory-files directory t file-name-regex)))
      ;; loop over directory listing

      (dolist (file-or-dir cur-dir-list org-file-list) ; returns org-file-list
        (cond
         ((file-regular-p file-or-dir) ; regular files
          (if (string-match fileregex file-or-dir) ; org files
              (add-to-list 'org-file-list file-or-dir)))
         ((file-directory-p file-or-dir)
          (dolist (org-file (sa-find-org-file-recursively file-or-dir
                                                          filext)
                            org-file-list) ; add files found to result
            (add-to-list 'org-file-list org-file)))))))

  (setq-default
   ;; files that appear in the agenda
   org-agenda-files (list
                     (concat org-directory "/current.org")
                     (concat org-directory "/goals.org"))
   ;; files that are candidates for searches in addition to agenda files
   org-agenda-text-search-extra-files
    (append
      (sa-find-org-file-recursively (concat org-directory "/dates"))
      (sa-find-org-file-recursively (concat org-directory "/topics"))
      (list (concat org-directory "/kb.org")
            (concat org-directory "/notnow.org")
            (concat org-directory "/rwl.org")))
   ;; Make the tags not squished to the left in the agenda
   ;; Here they are right-aligned to column 100
   org-agenda-tags-column -100
   org-deadline-warning-days 1
   org-agenda-custom-commands
    '(("c" "Captured/To Review" tags "captured|review"
          ((org-agenda-overriding-header "Captured/To Review")
           (org-tags-match-list-sublevels nil)))
      ("h" "Homework" tags-todo "hw"
          ((org-agenda-overriding-header "Homework")
           (org-agenda-sorting-strategy '(deadline-up effort-down))
           (org-agenda-overriding-columns-format
             "%50ITEM(Item) %HW_CLASS(Class) %DEADLINE(Deadline) %Effort")
           (org-agenda-view-columns-initially t)))
      ("w" "Waiting/Hold tasks" tags "TODO=\"ON HOLD\"|TODO=\"WAITING\""
          ((org-agenda-overriding-header "Waiting/Hold Tasks")
           (org-tags-match-list-sublevels nil)))
      ("d" "David's planner view"
        ;; for some reason org-mode thinks my day starts at 04:00. Since timestamps with
        ;; no time are at 00:00 by default, this makes the days all screwed up, so I've
        ;; made them all off by 1 in the opposite direction to correct for this.
        ((tags-todo "STYLE=\"habit\"+SCHEDULED<\"<tomorrow>\""
                    ((org-agenda-overriding-header "Habits")))
         (tags-todo "TODO=\"TODO\"+SCHEDULED<\"<-1d>\""
                    ((org-agenda-overriding-header "Overdue Tasks")))
         (tags-todo "TODO=\"TODO\"+SCHEDULED>=\"<-1d>\"+SCHEDULED<\"<today>\""
                    ((org-agenda-overriding-header "Today's Tasks")))
         (tags-todo "TODO=\"TODO\"+SCHEDULED>=\"<today>\"+SCHEDULED<\"<tomorrow>\""
                    ((org-agenda-overriding-header "Tomorrow's Tasks")))
         (todo "TODO"
               ((org-agenda-overriding-header "Ongoing Projects")
                (org-agenda-skip-function 'dru/keep-non-stuck-projects)
                (org-tags-match-list-sublevels nil)))
         (todo "TODO"
                ((org-agenda-overriding-header "Stuck Projects")
                 (org-agenda-skip-function 'dru/keep-stuck-projects)
                 (org-tags-match-list-sublevels nil)))))))
#+END_SRC
* refile
I use refile extensively.
#+BEGIN_SRC emacs-lisp
  ;; set an easy keybinding for refile
  (spacemacs/set-leader-keys-for-major-mode 'org-mode "r" 'org-refile)
  (setq-default
   org-refile-targets '(("current.org" :maxlevel . 9)
                        ("goals.org" :maxlevel . 9)
                        ("kb.org" :maxlevel . 9)
                        ("notnow.org" :maxlevel . 9)
                        ("rwl.org" :maxlevel . 9))
   org-outline-path-complete-in-steps t ;; Refile in a single go
   org-refile-use-outline-path 'file ;; Show full paths for refiling
   )
#+END_SRC
* capture
#+BEGIN_SRC emacs-lisp
  (setq-default
    org-default-notes-file "/home/david/s/doc/notes/notes.md"
    org-capture-templates
    ;; most-used templates
    `(("t" "TODO" entry (file+headline ,(concat org-directory "/current.org") "todo")
        "* TODO %?   :captured:\n" :prepend t)
      ("h" "thought" entry (file+headline ,(concat org-directory "/current.org") "thoughts")
        "* %?\n")
      ("n" "note" entry (file+headline ,(concat org-directory "/current.org") "notes")
        "* %?\n")
      ;; templates for rwl.org
      ("r" "Templates for stuff to read")
      ("rb" "book" item (file+headline ,(concat org-directory "/rwl.org") "books")
        "- [ ] %?\n" :prepend t)
      ("rp" "paper" item (file+headline ,(concat org-directory "/rwl.org") "papers")
        "- [ ] %?\n" :prepend t)
      ("w" "Templates for stuff to watch")
      ("wm" "movie" item (file+headline ,(concat org-directory "/rwl.org") "movies")
        "- [ ] %?\n" :prepend t)
      ("wt" "TV show" item (file+headline ,(concat org-directory "/rwl.org") "tv shows")
        "- [ ] %?\n" :prepend t)
      ("wa" "anime" item (file+headline ,(concat org-directory "/rwl.org") "anime")
        "- [ ] %?\n" :prepend t)
      ("wv" "video" item (file+headline ,(concat org-directory "/rwl.org") "videos")
        "- [ ] %?\n" :prepend t)
      ("l" "Templates for stuff to listen to")
      ("lm" "music")
      ("lmc" "check out" item (file+headline ,(concat org-directory "/rwl.org") "check out")
        "- [ ] %?\n" :prepend t)
      ("lmd" "download" item (file+headline ,(concat org-directory "/rwl.org") "download")
        "- [ ] %?\n" :prepend t)
      ("lp" "podcast" item (file+headline ,(concat org-directory "/rwl.org") "podcasts")
        "- [ ] %?\n" :prepend t)
      ;; misc template; goes to notes file
      ("m" "Misc" plain (file "") "%?" :empty-lines 1))
   )
  ;; start org-capture buffer in insert state
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC
* habits
I use the ~org-habit~ module to track my habits. It's not enabled by default, so
I have to enable it and set it up manually.
#+BEGIN_SRC emacs-lisp
  (setq-default 
   ;; enable org-mode habit tracking
   org-modules (append org-modules '(org-habit))
   ;; log habits to the "logbook" drawer
   org-log-into-drawer "LOGBOOK"
   ;; on the habit-tracking graph in the agenda,
   ;; show 1 month (30 days) of previous progress and 1 day of future progress
   org-habit-preceding-days 30
   org-habit-following-days 1
   ;; move the habit-tracking graph to the right so that it doesn't cut off the
   ;; habit name
   org-habit-graph-column 80
   ;; do not show the habits in the calendar!
   org-habit-show-habits nil)
#+END_SRC
** display habits in special agenda block instead of schedule
I like the habit-tracking graphs that appear in the agenda schedule by default,
but I don't use the agenda schedule (see [[agenda]]), so this code displays the
habit-tracking graphs in their own agenda block instead.
#+BEGIN_SRC emacs-lisp
  (defvar my/org-habit-show-graphs-everywhere t
    "If non-nil, show habit graphs in all types of agenda buffers.

    Normally, habits display consistency graphs only in
    \"agenda\"-type agenda buffers, not in other types of agenda
    buffers.  Set this variable to any non-nil variable to show
    consistency graphs in all Org mode agendas.")

  (defun my/org-agenda-mark-habits ()
    "Mark all habits in current agenda for graph display.

    This function enforces `my/org-habit-show-graphs-everywhere' by
    marking all habits in the current agenda as such.  When run just
    before `org-agenda-finalize' (such as by advice; unfortunately,
    `org-agenda-finalize-hook' is run too late), this has the effect
    of displaying consistency graphs for these habits.

    When `my/org-habit-show-graphs-everywhere' is nil, this function
    has no effect."
    (when (and my/org-habit-show-graphs-everywhere
               (not (get-text-property (point)
                                       'org-series)))
      (let ((cursor (point)) item
            data)
        (while (setq cursor (next-single-property-change cursor 'org-marker))
          (setq item (get-text-property cursor 'org-marker))
          (when (and item
                     (org-is-habit-p item))
            (with-current-buffer (marker-buffer item)
              (setq data (org-habit-parse-todo item)))
            (put-text-property cursor
                               (next-single-property-change cursor 'org-marker)
                               'org-habit-p
                               data))))))

  (advice-add #'org-agenda-finalize :before #'my/org-agenda-mark-habits)
#+END_SRC
* projects
** helper functions
taken from http://doc.norang.ca/org-mode.html#GTDWeeklyReview
#+BEGIN_SRC emacs-lisp
  (defun bh/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))

  ;; note that this function is exactly the same as bh/is-project-p except for the
  ;; last line
  (defun bh/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let
        ((has-subtask)
         (subtree-end (save-excursion (org-end-of-subtree t)))
         (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task (not has-subtask)))))

  (defun bh/find-project-task ()
    "Move point to the parent (project) task if any"
    (save-restriction
      (widen)
      (let
        ((parent-task
          (save-excursion
           (org-back-to-heading 'invisible-ok)
           (point))))
        (while (org-up-heading-safe)
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (goto-char parent-task)
        parent-task)))

  (defun bh/is-project-subtree-p ()
    "Any task with a todo keyword that is in a project subtree.
  Callers of this function already widen the buffer view."
    (let ((task (save-excursion
                  (org-back-to-heading 'invisible-ok)
                  (point))))
      (save-excursion
        (bh/find-project-task)
        (if (equal (point) task)
            nil
          t))))

  ;; any TODO keyword that is a child of another TODO keyword. So for the purposes
  ;; of this function, leaf nodes are also subprojects
  (defun bh/is-subproject-p ()
    "Any task which is a subtask of another project"
    (let ((is-subproject)
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (while (and (not is-subproject)
                    (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq is-subproject t))))
      (and is-a-task is-subproject)))


  (defun bh/skip-non-projects ()
    "Skip trees that are not projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (if (save-excursion (bh/skip-non-stuck-projects))
        (save-restriction
          (widen)
          (let
            ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p) nil)
             ((and (bh/is-project-subtree-p)
                   (not (bh/is-task-p))) nil)
             (t subtree-end))))
        (save-excursion
          (org-end-of-subtree t))))

  ;; NOTE these two functions are exactly the same except for one line
  (defun dru/keep-stuck-projects ()
    "Skip trees that are not stuck projects (i.e. only keep stuck projects)"
    (save-restriction
      (widen)
      (let
          ((next-headline
            (save-excursion
              (or (outline-next-heading)
                  (point-max)))))
        (if (bh/is-project-p)
            (let*
                ((subtree-end
                  (save-excursion
                    (org-end-of-subtree t)))
                 (has-next))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next)
                            (< (point) subtree-end)
                            (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next next-headline nil)) ; a stuck project, has subtasks but no next task
          next-headline))))

  (defun dru/keep-non-stuck-projects ()
    "Skip trees that are not ongoing projects (i.e. only keep ongoing projects)"
    (save-restriction
      (widen)
      (let
          ((next-headline
            (save-excursion
              (or (outline-next-heading)
                  (point-max)))))
        (if (bh/is-project-p)
            (let*
                ((subtree-end
                  (save-excursion
                    (org-end-of-subtree t)))
                 (has-next))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next)
                            (< (point) subtree-end)
                            (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next nil next-headline))
          next-headline))))

#+END_SRC
* calendar
I use the [[https://github.com/kiwanami/emacs-calfw][calfw]] package for my calendar in place of the built-in agenda
schedule, because it actually looks like a calendar, which I really like. I use
[[https://github.com/kiwanami/emacs-calfw][org-gcal]] to sync this with google calendar, which is synced with an app on my phone.
#+BEGIN_SRC emacs-lisp
  ;; org-gcal settings are in emacs.secrets
  (setq-default
    org-gcal-client-id my-org-gcal-client-id
    org-gcal-client-secret my-org-gcal-client-secret
    org-gcal-file-alist `((,my-org-gcal-email . ,(concat org-directory "/cal.org"))))

  (defun dudelson/org-cal-transformer (s)
    "test"
    s)

  ;; calfw-org settings
  (setq-default
   cfw:org-schedule-summary-transformer 'dudelson/org-cal-transformer)
#+END_SRC
* keybindings
Add an easy keybinding for setting TODO keywords and bring back the old
keybinding for setting tags that I liked and am used to
#+BEGIN_SRC emacs-lisp
  (spacemacs/set-leader-keys-for-major-mode 'org-mode "w" 'org-todo)
  (spacemacs/set-leader-keys-for-major-mode 'org-mode ":" 'org-set-tags)
#+END_SRC

These keybindings do the same thing as the default ~C-ret~ and ~M-ret~
keybindings, except they also automatically enter evil-insert-state.
#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map (kbd "C-<return>") (lambda ()
                                                (interactive)
                                                (org-insert-heading-respect-content)
                                                (evil-insert 1)))
  (define-key org-mode-map (kbd "M-<return>") (lambda ()
                                                (interactive)
                                                (org-meta-return)
                                                (evil-insert 1)))
#+END_SRC

Automatically git commit after weekly planning and daily adapting.
#+BEGIN_SRC emacs-lisp
  (defun dru/org-auto-vc (message)
    "Automatically adds and commits all org files.
     'message' arg is the commit message. A timestamp will be automatically
     added after this message."
    (shell-command
      (concat
        "cd ~/s/doc/org && git commit -am '"
        message
        " "
        (format-time-string "%a %D")
        "'")))

  (defun dru/org-auto-vc-daily ()
    "Automatically git commit all org files after daily adapting"
    (interactive)
    (dru/org-auto-vc "Daily adapting"))

  (defun dru/org-auto-vc-weekly ()
    "Automatically git commit all org files after weekly planning"
    (interactive)
    (dru/org-auto-vc "Weekly planning"))

  (spacemacs/set-leader-keys-for-major-mode 'org-mode "vd" 'dru/org-auto-vc-daily)
  (spacemacs/set-leader-keys-for-major-mode 'org-mode "vw" 'dru/org-auto-vc-weekly)
#+END_SRC
Might be useful for testing new project definition later
(defun dru/is-project ()
  "Print a message indicating whether the heading under point is a project"
  (interactive)
  (if (bh/is-project-p)
      (message "project")
    (message "nope")))

(define-key org-mode-map (kbd "C-c C-m") 'dru/is-project)
* other useful tidbits
** easy linking by id
I use the "id" property to link between org files. This function automatically
creates an id for a heading if one doesn't already exist and copies the id to
the clipboard.
#+BEGIN_SRC emacs-lisp
  (defun dudelson/org-id-create-and-copy ()
    (interactive)
    (org-id-get-create)
    (org-id-copy))
  (define-key org-mode-map (kbd "C-l") 'dudelson/org-id-create-and-copy)
#+END_SRC
